## cheet_sheet_SQL_window
window w as (order by salary desc)


- **row_number()** :: порядковый номер строки
- **dense_rank()** :: ранг строки
- **rank()** ::	тоже ранг, но с пропусками
- **ntile(n)** :: разбивает все строки на n групп и возвращает номер группы, в которую попала строка

   <br>
- **lag(value, offset** :: значение value из строки, отстоящей на offset строк назад от текущей
- **lead(value, offset)** :: значение value из строки, отстоящей на offset строк вперед от текущей
- **first_value(value)** ::	значение value из первой строки фрейма
- **last_value(value)** ::	значение value из последней строки фрейма
- **nth_value(value, n)** ::	значение value из n-й строки фрейма
    <br><br>
**в какой последовательности действует движок, когда выполняет запрос:**

1. Взять нужные таблицы (from) и соединить их при необходимости (join)
2. Отфильтровать строки (where). 
3. Сгруппировать строки (group by).
4. Отфильтровать результат группировки (having).
5. Взять конкретные столбцы из результата (select).
6. Рассчитать значения оконных функций (function() over window).
7. Отсортировать то, что получилось (order by).

**Определение окна указывает, как выглядит окно:**
- Из каких секций состоит (partition by).
- Как отсортированы строки внутри секции (order by).
- Как выглядит фрейм внутри секции (rows between).

``rows between X preceding and Y following``<br>
Где X — количество строк перед текущей, а Y — количество строк после текущей:
<br>(rows between unbounded preceding and current row). - значение по **default**

{ ROWS | GROUPS | RANGE } BETWEEN frame_start AND frame_end
1. rows-фрейм оперирует строками,
2. groups —  оперируют группами записей с одинаковым набором значений столбцов из order by;
3. range —  оперируют группами записей, у которых значение столбца из order by попадает в указанный диапазон.

**EXCLUDE:**

1. EXCLUDE NO OTHERS. Ничего не исключать. Вариант по умолчанию: если явно не указать exclude, сработает именно он.
2. EXCLUDE CURRENT ROW. Исключить текущую запись (как мы сделали на предыдущем шаге с сотрудником).
3. EXCLUDE GROUP. Исключить текущую запись и все равные ей (по значению столбцов из order by).
4. EXCLUDE TIES. Оставить текущую запись, но исключить равные ей.

**FILTER**
- sum(salary*1.5)  filter(where department <> 'it') over w as "+50% без ИТ"
- sum(case when department = 'it' then salary else salary*1.1 end ) over w as "+10% кроме ИТ"

CASE — универсальный и более гибкий способ фильтрации записей фрейма, чем FILTER. К тому же его поддерживают все СУБД (в отличие от FILTER).
